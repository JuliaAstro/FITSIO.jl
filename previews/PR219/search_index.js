var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#File-operations","page":"API Reference","title":"File operations","text":"","category":"section"},{"location":"api/#FITSIO.FITS","page":"API Reference","title":"FITSIO.FITS","text":"FITS(filename::String[, mode::String = \"r\"]; extendedparser = true)\n\nOpen or create a FITS file. mode can be one of \"r\" (read-only), \"r+\" (read-write) or \"w\" (write). In \"write\" mode, any existing file of the same name is overwritten.\n\nA FITS object is a collection of \"Header-Data Units\" (HDUs) and supports the following operations:\n\nf[i]: Return the i-th HDU.\nf[name] or f[name, ver]: Return the HDU containing the given the given EXTNAME (or HDUNAME) keyword (a String), and optionally the given EXTVER (or HDUVER) number (an Integer).\nIteration:\nfor hdu in f\n    ...\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.length","page":"API Reference","title":"Base.length","text":"length(f::FITS)\n\nNumber of HDUs in the file.\n\n\n\n\n\nlength(hdr::FITSHeader)\n\nNumber of records in header of HDU.\n\n\n\n\n\nlength(hdu::ImageHDU)\n\nGet total number of pixels in image (product of size(hdu)).\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.flush","page":"API Reference","title":"Base.flush","text":"flush(f::FITS)\n\nFlush the FITS file to disk. This is equivalent to closing and reopening the file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.close","page":"API Reference","title":"Base.close","text":"close(f::FITS)\n\nClose the file.\n\nSubsequent attempts to operate on f will result in an error. FITS objects are also automatically closed when they are garbage collected.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.deleteat!","page":"API Reference","title":"Base.deleteat!","text":"deleteat!(f::FITS, i::Integer)\n\nDelete the HDU at index i in the FITS file. If i == 1, this deletes the primary HDU and replaces it with a bare HDU with no data and a minimal header. If i > 1, this removes the HDU at index i and moves the following HDUs forward.\n\n\n\n\n\n","category":"function"},{"location":"api/#Header-operations","page":"API Reference","title":"Header operations","text":"","category":"section"},{"location":"api/#FITSIO.read_key","page":"API Reference","title":"FITSIO.read_key","text":"read_key(hdu::HDU, key::String) -> (value, comment)\n\nRead the HDU header record specified by keyword and return a tuple where value is the keyword parsed value (of type String, Bool, Int, Float64 or Nothing), comment is the keyword comment (as a string). Throw an error if key is not found.\n\n\n\n\n\nread_key(hdu::HDU, key::Integer) -> (keyname, value, comment)\n\nSame as above but FITS card is specified by its position and returns a 3 element tuple where keyname is the keyword name (a string).\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.write_key","page":"API Reference","title":"FITSIO.write_key","text":"write_key(hdu::HDU, key::String, value[, comment])\n\nWrite a keyword value the HDU's header. value can be a standard header type (String, Bool, Integer, AbstractFloat) or nothing, in which case the value part of the record will be empty. If the keyword already exists, the value will be overwritten. The comment will only be overwritten if given. If the keyword does not already exist, a new record will be appended at the end of the header.\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.read_header","page":"API Reference","title":"FITSIO.read_header","text":"read_header(filename::AbstractString, hduindex = 1) -> FITSHeader\n\nConvenience function to read the entire header corresponding to the HDU at index hduindex contained in the FITS file named filename. Functionally read_header(filename, hduindex) is equivalent to\n\nFITS(filename, \"r\") do f\n    read_header(f[hduindex])\nend\n\n\n\n\n\nread_header(hdu::HDU) -> FITSHeader\n\nRead the entire header from the given HDU and return a FITSHeader object. The value of each header record is parsed as Int, Float64, String, Bool or nothing according to the FITS standard.\n\nIf the value cannot be parsed according to the FITS standard, the value is stored as the raw unparsed String.\n\n\n\n\n\nread_header(hdu::HDU, String) -> String\n\nRead the entire header from the given HDU as a single string.\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.FITSHeader","page":"API Reference","title":"FITSIO.FITSHeader","text":"FITSHeader(keys::Vector{String}, values::Vector, comments::Vector{String})\n\nAn in-memory representation of the header of an HDU. It stores the (key, value, comment) information for each 80-character \"card\" in a header.\n\nNote that this structure is not linked to a FITS file in any way; it is just a convenient structure for storing the header contents after reading from a file. (This is similar to how an Array returned by read(f[1]) is not linked to the FITS file f.)  Manipulating a FITSHeader will therefore have no immediate impact on any file, even if it was created by read_header(::HDU).  You can, however, write a FITSHeader to a file using the write(::FITS, ...) methods that append a new HDU to a file.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.length-Tuple{FITSHeader}","page":"API Reference","title":"Base.length","text":"length(hdr::FITSHeader)\n\nNumber of records in header of HDU.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.haskey-Tuple{FITSHeader, String}","page":"API Reference","title":"Base.haskey","text":"haskey(hdr::FITSHeader, key::String)\n\nReturns true if key exists in header, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.keys-Tuple{FITSHeader}","page":"API Reference","title":"Base.keys","text":"keys(hdr::FITSHeader)\n\nArray of keywords in header of HDU (not a copy).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.values-Tuple{FITSHeader}","page":"API Reference","title":"Base.values","text":"values(hdr::FITSHeader)\n\nArray of values in header of HDU (not a copy).\n\n\n\n\n\n","category":"method"},{"location":"api/#FITSIO.get_comment","page":"API Reference","title":"FITSIO.get_comment","text":"get_comment(hdr::FITSHeader, key_or_index::Union{String,Integer})\n\nGet the comment based on keyword or index.\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.set_comment!","page":"API Reference","title":"FITSIO.set_comment!","text":"set_comment!(hdr::FITSHeader, key_or_index::Union{String,Integer}, comment::String)\n\nSet the comment based on keyword or index.\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.default_header","page":"API Reference","title":"FITSIO.default_header","text":"default_header(data::AbstractArray)\n\nCreates a default header for the given array with the SIMPLE, BITPIX, NAXIS, NAXIS*, and EXTEND entries.\n\n\n\n\n\n","category":"function"},{"location":"api/#Image-operations","page":"API Reference","title":"Image operations","text":"","category":"section"},{"location":"api/#Base.read-Tuple{ImageHDU}","page":"API Reference","title":"Base.read","text":"read(hdu::ImageHDU)\nread(hdu::ImageHDU, range...)\n\nRead the data array or a subset thereof from disk. The first form reads the entire data array. The second form reads a slice of the array given by the specified ranges or integers. Dimensions specified by integers will be dropped in the returned array, while those specified by ranges will be retained.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read!","page":"API Reference","title":"Base.read!","text":"read!(hdu::ImageHDU, A::StridedArray)\nread!(hdu::ImageHDU, A::StridedArray, range...)\n\nRead the data or a subset thereof from disk, and save it in a pre-allocated output array A. The first form reads the entire data from disk. The second form reads a slice of the array given by the specified ranges or integers. The array A needs to have the same length as the number of elements to be read in. Additionally A needs to be stored contiguously in memory.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of the axes flipped when read in using FITSIO.\n\n\n\n\n\n","category":"function"},{"location":"api/#FITSIO.fitsread","page":"API Reference","title":"FITSIO.fitsread","text":"fitsread(filename::AbstractString[, hduindex = 1[, arrayindices...]]; extendedparser = true)\n\nConvenience function to read in an image corresponding to the HDU at index hduindex contained in the FITS file named filename. If arrayindices are provided, only a slice of the image corresponding to the indices is read in.\n\nFunctionally fitsread(filename, hduindex, arrayindices...; extendedparser) is equivalent to\n\nFITS(filename, \"r\"; extendedparser = extendedparser) do f\n    read(f[hduindex], arrayindices...)\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\nnote: Note\nJulia follows a column-major array indexing convention, so the indices provided must account for this. In particular this means that FITS files created externally following a row-major convention (eg. using astropy) will have the sequence of axes flipped when read in using FITSIO.\n\nSee also: read\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.write-Tuple{FITS, StridedArray{<:Real}}","page":"API Reference","title":"Base.write","text":"write(f::FITS, data::StridedArray{<:Real}; header=nothing, name=nothing, ver=nothing)\n\nAdd a new image HDU to FITS file f with contents data. The following array element types are supported: UInt8, Int8, UInt16, Int16, UInt32, Int32, Int64, Float32, Float64. If a FITSHeader object is passed as the header keyword argument, the header will also be added to the new HDU. The data to be written out must be stored contiguously in memory.\n\ntip: Unsupported element types\nIt might be possible to write out an array with an element type other than those mentioned above by reinterpreting it as one that is supported. For example, to write out a Complex array and read it back in, we may usejulia> a = rand(ComplexF64, 2)\n2-element Array{Complex{Float64},1}:\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041im\n\n# We may write this out as Float64\njulia> FITSIO.fitswrite(\"temp.fits\", reinterpret(Float64, a))\n\n# reinterpret it back as a complex one while reading it in\njulia> reinterpret(ComplexF64, FITSIO.fitsread(\"temp.fits\"))\n2-element reinterpret(Complex{Float64}, ::Array{Float64,1}):\n 0.4943325325752195 + 0.2034650017475852im\n 0.2495752009567498 + 0.819163869249041imWhile this often works in practice, such a workaround is not officially supported by FITSIO, and care must be taken to ensure the correctness of data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{ImageHDU, StridedArray{<:Real}}","page":"API Reference","title":"Base.write","text":"write(hdu::ImageHDU, data::StridedArray{<:Real})\n\nWrite data to an existing image HDU. The data to be written out must be stored contiguously in memory.\n\n\n\n\n\n","category":"method"},{"location":"api/#FITSIO.fitswrite","page":"API Reference","title":"FITSIO.fitswrite","text":"fitswrite(filename::AbstractString, data; extendedparser = true, kwargs...)\n\nConvenience function to write the image array data to a file named filename.\n\nFunctionally fitswrite(filename, data; extendedparser, kwargs...) is equivalent to\n\nFITS(filename, \"w\"; extendedparser = extendedparser) do f\n    write(f, data; kwargs...)\nend\n\nThe keyword argument extendedparser may be used to enable or disable the extended filename parser. If disabled, filename is treated exactly as the name of the file and is not tokenized into parameters.\n\nwarn: Warning\nExisting files with the same name will be overwritten.\n\nSee also: write\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.eltype-Tuple{ImageHDU}","page":"API Reference","title":"Base.eltype","text":"eltype(hdu::ImageHDU)\n\nReturn the element type of the image in hdu.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.ndims-Tuple{ImageHDU}","page":"API Reference","title":"Base.ndims","text":"ndims(hdu::ImageHDU)\n\nGet number of image dimensions, without reading the image into memory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{ImageHDU}","page":"API Reference","title":"Base.size","text":"size(hdu::ImageHDU)\nsize(hdu::ImageHDU, i)\n\nGet image dimensions (or ith dimension), without reading the image into memory.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{ImageHDU}","page":"API Reference","title":"Base.length","text":"length(hdu::ImageHDU)\n\nGet total number of pixels in image (product of size(hdu)).\n\n\n\n\n\n","category":"method"},{"location":"api/#FITSIO.copy_section","page":"API Reference","title":"FITSIO.copy_section","text":"copy_section(hdu, dest, r...)\n\nCopy a rectangular section of an image and write it to a new FITS primary image or image extension in FITS object dest. The new image HDU is appended to the end of dest. All the keywords in the input image will be copied to the output image. The common WCS keywords will be updated if necessary to correspond to the coordinates of the section.\n\nExamples\n\nCopy the lower-left 200 x 200 pixel section of the image in hdu to an open file, f\n\ncopy_section(hdu, f, 1:200, 1:200)\n\nSame as above but only copy odd columns in y:\n\ncopy_section(hdu, f, 1:200, 1:2:200)\n\n\n\n\n\n","category":"function"},{"location":"api/#Table-operations","page":"API Reference","title":"Table operations","text":"","category":"section"},{"location":"api/#FITSIO.colnames","page":"API Reference","title":"FITSIO.colnames","text":"colnames(hdu) -> Vector{String}\n\nReturn the names of columns in a table HDU.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.write-Tuple{FITS, Dict{String}}","page":"API Reference","title":"Base.write","text":"write(f::FITS, data::Dict;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing)\n\nCreate a new table extension and write data to it. If the FITS file is currently empty then a dummy primary array will be created before appending the table extension to it. data should be a dictionary with String keys (giving the column names) and Array values (giving data to write to each column). The following types are supported in binary tables: UInt8, Int8, UInt16, Int16, UInt32, Int32, UInt64, Int64, Float32, Float64, Complex{Float32}, Complex{Float64}, String, Bool.\n\nOptional inputs:\n\nhdutype: Type of table extension to create. Can be either TableHDU (binary table) or ASCIITableHDU (ASCII table).\nname: Name of extension.\nver: Version of extension (Int).\nheader: FITSHeader instance to write to new extension.\nunits: Dictionary mapping column name to units (as a string).\nvarcols: An array giving the column names or column indicies to write as \"variable-length columns\".\n\nnote: Variable length columns\nVariable length columns allow a column's row entries to contain arrays of different lengths. They can potentially save diskspace when the rows of a column vary greatly in length, as the column data is all written to a contiguous heap area at the end of the table. Only column data of type Vector{String} or types such as Vector{Vector{UInt8}} can be written as variable length columns. In the second case, ensure that the column data type is a leaf type. That is, the type cannot be Vector{Vector{T}}, which would be an array of arrays having potentially non-uniform element types (which would not be writable as a FITS table column).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.write-Tuple{FITS, Vector{String}, Vector}","page":"API Reference","title":"Base.write","text":"write(f::FITS, colnames, coldata;\n      hdutype=TableHDU, name=nothing, ver=nothing,\n      header=nothing, units=nothing, varcols=nothing)\n\nSame as write(f::FITS, data::Dict; ...) but providing column names and column data as a separate arrays. This is useful for specifying the order of the columns. Column names must be Vector{String} and column data must be a vector of arrays.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.read-Tuple{TableHDU, String}","page":"API Reference","title":"Base.read","text":"read(hdu::TableHDU, colname; case_sensitive=true)\n\nRead a column as an array from the given table HDU.\n\nThe column name may contain wild card characters (*, ?, or #). The * wild card character matches any sequence of characters (including zero characters) and the ? character matches any single character. The # wildcard will match any consecutive string of decimal digits (0-9). The string must match a unique column.  The optional boolean keyword case_sensitive, true by default, specifies whether the column name is to be considered case sensitive.\n\nnote: Array order\nJulia arrays are column-major (like Fortran), not row-major (like C and numpy), so elements of multi-dimensional columns will be the transpose of what you get with astropy.\n\n\n\n\n\n","category":"method"},{"location":"#FITSIO.jl","page":"Introduction","title":"FITSIO.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: GitHub) (Image: Build Status) (Image: Coverage Status)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A Julia package for reading and writing Flexible Image Transport System (FITS) files, based on the cfitsio library.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The interface is inspired by Erin Sheldon's fitsio Python package.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Warning\nThe Libcfitsio submodule has been moved to CFITSIO.jl and will be deprecated in a future release.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FITSIO.jl can be installed using the built-in package manager:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add FITSIO","category":"page"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The simplest way to write and read an image from a FITS file is by using the functions FITSIO.fitswrite and FITSIO.fitsread.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> fname, _ = mktemp(); # create a temporary file for this example\n\njulia> using FITSIO\n\njulia> FITSIO.fitswrite(fname, [1 2; 3 4]) # creates a new file with the data\n\njulia> FITSIO.fitsread(fname) # opened in a read-only mode\n2×2 Matrix{Int64}:\n 1  2\n 3  4\n\njulia> FITSIO.fitsread(fname, 1, 1:2, 1) # read a section of HDU number 1\n2-element Vector{Int64}:\n 1\n 3","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This is not the most performant way, as the file is opened and closed on every invocation. However, this abstracts away the complexity.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warn: Warn\nCurrently, fitswrite overwrites an existing file, so this should be used with caution. In the future, this may allow appending to an existing file.","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In this example, we write to and read from a fits file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We create a new temporary file using the FITS constructor:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> fname, _ = mktemp(); # create a temporary file for this example\n\njulia> using FITSIO\n\njulia> f = FITS(fname, \"w\") # create a new fits file\nFile: /tmp/jl_td8sL6\nMode: \"w\" (read-write)\nNo HDUs.\n\njulia> length(f) # shows the number of HDUs in the file\n0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"In this example, we have used the file mode \"w\", which will overwrite any existing file with the same name. To append to an existing file instead, we use the mode \"r+\", and to open a file for reading, we may specify the mode \"r\".","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A FITS file consists of one or more header-data units (HDUs), concatenated one after the other. The FITS object therefore is represented as a collection of these HDUs. Each HDU can contain image data, or table data (either binary or ASCII-formatted). Since we have just created a new file, there are no HDUs currently in the file.","category":"page"},{"location":"#Image","page":"Introduction","title":"Image","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We write an array to the file, which will automatically create an image HDU.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> data = Array(reshape(1:20, 4, 5))\n4×5 Matrix{Int64}:\n 1  5   9  13  17\n 2  6  10  14  18\n 3  7  11  15  19\n 4  8  12  16  20\n\njulia> write(f, data)\n\njulia> length(f) # an HDU should now be added\n1\n\njulia> f # show information about the file\nFile: /tmp/jl_MdlNSQ\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type\n      1          Image\n\njulia> imghdu = f[1] # get the first image HDU\nFile: /tmp/jl_q95Lxk\nHDU: 1\nMode: read-write\nType: Image\nDatatype: Int64\nDatasize: (4, 5)\n\njulia> typeof(imghdu)\nImageHDU{Int64, 2}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may query the properties of an image HDU analogous to an array.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> eltype(imghdu)\nInt64\n\njulia> ndims(imghdu)\n2\n\njulia> size(imghdu)\n(4, 5)\n\njulia> size(imghdu, 1)\n4\n\njulia> length(imghdu)\n20","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may read the entire data array or a section of it using read. This is analogous to indexing into an array.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> read(imghdu)\n4×5 Matrix{Int64}:\n 1  5   9  13  17\n 2  6  10  14  18\n 3  7  11  15  19\n 4  8  12  16  20\n\njulia> read(imghdu, 1:3, 2:4)\n3×3 Matrix{Int64}:\n 5   9  13\n 6  10  14\n 7  11  15\n\njulia> read(imghdu, 1:3, 3)\n3-element Vector{Int64}:\n  9\n 10\n 11\n\njulia> read(imghdu, :, 2:3)\n4×2 Matrix{Int64}:\n 5   9\n 6  10\n 7  11\n 8  12","category":"page"},{"location":"#Table","page":"Introduction","title":"Table","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In this section, we re-use the file that we had created in the earlier sections that contains an image HDU. We append a binary table HDU to the file:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> data = Dict(\"col1\"=>[1., 2., 3.], \"col2\"=>[1, 2, 3]);\n\njulia> write(f, data)\n\njulia> length(f) # check that a second HDU is now added\n2\n\njulia> f # the FITS object now contains two HDUs\nFile: /tmp/jl_q95Lxk\nMode: \"w\" (read-write)\nHDUs: Num  Name  Type\n      1          Image\n      2          Table\n\njulia> tablehdu = f[2]\nFile: /tmp/jl_q95Lxk\nHDU: 2\nType: Table\nRows: 3\nColumns: Name  Size  Type     TFORM\n         col2        Int64    1K\n         col1        Float64  1D\n\njulia> typeof(tablehdu)\nTableHDU","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may read a column from a table HDU as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> read(tablehdu, \"col1\")\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Table HDUs implement the Tables.jl interface, so you can load them into other table types, like DataFrames.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> using DataFrames\n\njulia> df = DataFrame(tablehdu)\n3×2 DataFrame\n Row │ col2   col1\n     │ Int64  Float64\n─────┼────────────────\n   1 │     1      1.0\n   2 │     2      2.0\n   3 │     3      3.0","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Variable length columns are not supported by the Tables.jl interface, and Tables methods will ignore them.","category":"page"},{"location":"#Header","page":"Introduction","title":"Header","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In this section, we re-use the file that we had created in the eariler section, which contains an image HDU and a table HDU.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may read the header of an HDU as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> header = read_header(imghdu)\nSIMPLE  =                    T / file does conform to FITS standard\nBITPIX  =                   64 / number of bits per data pixel\nNAXIS   =                    2 / number of data axes\nNAXIS1  =                    4 / length of data axis 1\nNAXIS2  =                    5 / length of data axis 2\nEXTEND  =                    T / FITS dataset may contain extensions\nCOMMENT   FITS (Flexible Image Transport System) format is defined in 'Astronom\nCOMMENT   and Astrophysics', volume 376, page 359; bibcode: 2001A&A...376..359H\n\njulia> typeof(header)\nFITSHeader\n\njulia> length(header) # number of keys\n8","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This reads the entire header from the HDU into memory. The header object behaves like a dictionary that may be queried using its keys:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> keys(header)\n8-element Vector{String}:\n \"SIMPLE\"\n \"BITPIX\"\n \"NAXIS\"\n \"NAXIS1\"\n \"NAXIS2\"\n \"EXTEND\"\n \"COMMENT\"\n \"COMMENT\"\n\njulia> haskey(header, \"NAXIS\")\ntrue\n\njulia> header[\"NAXIS\"] # using the key name\n2\n\njulia> header[3] # using the key index\n2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may read the value and comment for a key as well, either using the key name or its index.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> read_key(imghdu, \"NAXIS\") # query by key name\n(2, \"number of data axes\")\n\njulia> read_key(imghdu, 3) # query by key index\n(\"NAXIS\", 2, \"number of data axes\")\n\njulia> get_comment(header, \"NAXIS\")\n\"number of data axes\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We may modify the header in memory as","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> header[\"NEWKEY\"] = 10;  # change or add a keyword\n\njulia> header[\"NEWKEY\"]\n10\n\njulia> set_comment!(header, \"NEWKEY\", \"this is a comment\");\n\njulia> get_comment(header, \"NEWKEY\")\n\"this is a comment\"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nManipulating a header only changes it in memory until it is written to disk. The header object in memory is not connected to the fits file. To write some header keywords in the new extension, pass a FITSHeader instance as a keyword: write(f, data; header=header)","category":"page"},{"location":"#Iterating-over-the-HDUs","page":"Introduction","title":"Iterating over the HDUs","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"We may iterate over the fits file to access individual HDUs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> for hdu in f\n           println(typeof(hdu))\n       end\nImageHDU{Int64, 2}\nTableHDU","category":"page"},{"location":"#Write-to-disk","page":"Introduction","title":"Write to disk","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Close the file to write the in-memory FITS file to disk.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> close(f)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FITS objects are also closed automatically when garbage collected.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Compressed storage\nSetting the file extension to .gz will automatically use GZIP compression and save on storage space.julia> FITS(\"abc.fits\", \"w\") do f # save the image uncompressed\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n325440\n\njulia> FITS(\"abc.fits.gz\", \"w\") do f # save the image compressed\n            write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits.gz\")\n2117Alternately the compression algorithm might be specified in square brackets after the filename. Check the CFITSIO website for the details of this usage.julia> FITS(\"abc.fits[compress R 100,100]\", \"w\") do f # Rice algorithm with a 100 x 100 pixel tile size\n           write(f, ones(200,200))\n       end\n\njulia> filesize(\"abc.fits\")\n8640warn: Warn\nCompression is \"loss-less\" for images with integer pixel values, and might be lossy for floating-point images.","category":"page"}]
}
